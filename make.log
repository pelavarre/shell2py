:
:
: copied from https://github.com/pelavarre/shell2py/blob/main/make.log
:
:
echo 'for P in bin/*.py; do echo | python3 -m pdb $P; done' |bash
> /Users/plavarre/Public/shell2py/bin/_scraps_.py(1)<module>()
-> """
(Pdb) (Pdb)
> /Users/plavarre/Public/shell2py/bin/echo.py(3)<module>()
-> """
(Pdb) (Pdb)
> /Users/plavarre/Public/shell2py/bin/find.py(3)<module>()
-> """
(Pdb) (Pdb)
> /Users/plavarre/Public/shell2py/bin/ls.py(3)<module>()
-> """
(Pdb) (Pdb)
> /Users/plavarre/Public/shell2py/bin/shell2py.py(3)<module>()
-> """
(Pdb) (Pdb)
> /Users/plavarre/Public/shell2py/bin/tar.py(3)<module>()
-> """
(Pdb) (Pdb)
:
:
~/.venvs/pips/bin/black bin/*.py
All done! ✨ 🍰 ✨
6 files left unchanged.
:
:
~/.venvs/pips/bin/flake8 --max-line-length=999 --ignore=E203,W503 bin/*.py
:
:
shell2py || echo "+ exit $?"
usage: shell2py.py [-h] VERB [WORD [WORD ...]]
shell2py.py: error: the following arguments are required: VERB
+ exit 2
:
shell2py -h
usage: shell2py.py [-h] VERB [WORD [WORD ...]]

translate the words, to python from bash

positional arguments:
  VERB        the first word of a shell line, being the program to run
  WORD        another word of a shell line, being an arg of the program to run

optional arguments:
  -h, --help  show this help message and exit

examples:
  shell2py -h  # show this help message and exit
  shell2py ls -1  # name each file or dir inside the current dir
:
shell2py --help
usage: shell2py.py [-h] VERB [WORD [WORD ...]]

translate the words, to python from bash

positional arguments:
  VERB        the first word of a shell line, being the program to run
  WORD        another word of a shell line, being an arg of the program to run

optional arguments:
  -h, --help  show this help message and exit

examples:
  shell2py -h  # show this help message and exit
  shell2py ls -1  # name each file or dir inside the current dir
:
:
shell2py ls || echo "+ exit $?"
usage: ls.py [--help] [-1]
ls.py: error: need stronger translator, meanwhile the 'ls.py --help' examples do work
+ exit 3
:
shell2py ls --help
usage: ls.py [--help] [-1]

show the files and dirs inside a dir

optional arguments:
  --help  show this help message and exit
  -1      print one filename or dirname per line

quirks:
  you must choose '-1' or '-l', because default 'ls' style needs 'os.get_terminal_size'

examples:
  ls.py --help  # show this help message and exit
  ls -1  # name each file or dir inside the current dir
:
shell2py ls -1 |cat -n |expand |sed 's,  *$,,'
     1  import os
     2
     3  filenames = sorted(os.listdir())
     4  for filename in filenames:
     5      if not filename.startswith("."):  # if not hidden
     6          print(filename)
bin/ls.py -1
Makefile
README.md
bin
make.log
:
:
shell2py echo 'Hello, Echo World!'
import sys

sys.argv = [None, "Hello, Echo World!"]  # delete this line to stop replacing the args

sys.stderr.flush()  # unneeded if not also writing Stderr
print(*sys.argv[1:])
sys.stdout.flush()  # unneeded if exiting now
bin/echo.py 'Hello, Echo World!'
Hello, Echo World!
:
shell2py echo --v 'Hello,' 'Echo World!'
import sys

sys.argv = [None, "Hello,", "Echo World!"]  # delete this line to stop replacing the args

for (index, arg) in enumerate(sys.argv):
    if index:
        print("{}: {!r}".format(index, arg))
bin/echo.py --v 'Hello,' 'Echo World!'
1: 'Hello,'
2: 'Echo World!'
:
shell2py echo -n '⌃ ⌥ ⇧ ⌘ ← → ↓ ↑ ⎋ ⇥ ⋮'
import sys

sys.argv = [None, "⌃ ⌥ ⇧ ⌘ ← → ↓ ↑ ⎋ ⇥ ⋮"]  # delete this line to stop replacing the args
str_args = " ".join(sys.argv[1:])

sys.stderr.flush()  # unneeded if not also writing Stderr
sys.stdout.write(str_args)  # tada, no line break
sys.stdout.flush()  # unneeded if exiting now
bin/echo.py -n '⌃ ⌥ ⇧ ⌘ ← → ↓ ↑ ⎋ ⇥ ⋮' |hexdump -C
00000000  e2 8c 83 20 e2 8c a5 20  e2 87 a7 20 e2 8c 98 20  |... ... ... ... |
00000010  e2 86 90 20 e2 86 92 20  e2 86 93 20 e2 86 91 20  |... ... ... ... |
00000020  e2 8e 8b 20 e2 87 a5 20  e2 8b ae                 |... ... ...|
0000002b
:
:
shell2py find -maxdepth 1 -type d
import os

def find(top):

    print(top)
    for (dirpath, dirnames, filenames) in os.walk(top):
        depth = 1 + dirpath.count(os.sep)

        if depth > 1:
            continue

        for dirname in dirnames:
            found_dir = os.path.join(dirpath, dirname)

            print(found_dir)


find(top=".")
bin/find.py -maxdepth 1 -type d |grep i
./bin
./.git
:
shell2py find -name '.?*'
import os

def find(top):

    print(top)
    for (dirpath, dirnames, filenames) in os.walk(top):

        for dirname in dirnames:
            found_dir = os.path.join(dirpath, dirname)
            if not dirname.startswith("."):  # if Dir isn't hidden
                continue

            print(found_dir)

        for filename in filenames:
            found_file = os.path.join(dirpath, filename)
            if not filename.startswith("."):  # if File isn't hidden
                continue

            print(found_file)

find(top=".")
bin/find.py -name '.?*' |head -3
.
./.git
./.touched-for-test
:
shell2py find -name '.?*' -prune -o -print
import os

def find(top):

    print(top)
    for (dirpath, dirnames, filenames) in os.walk(top):

        for dirname in dirnames:
            found_dir = os.path.join(dirpath, dirname)
            if dirname.startswith("."):  # if Dir is hidden
                continue

            print(found_dir)

        for filename in filenames:
            found_file = os.path.join(dirpath, filename)
            if filename.startswith("."):  # if File is hidden
                continue

            print(found_file)

find(top=".")
bin/find.py -name '.?*' -prune -o -print |head -3
.
./bin
./Makefile
:
shell2py find -type d
import os

def find(top):

    print(top)
    for (dirpath, dirnames, filenames) in os.walk(top):

        for dirname in dirnames:
            found_dir = os.path.join(dirpath, dirname)

            print(found_dir)


find(top=".")
bin/find.py -type d |head -3
.
./bin
./.git
:
shell2py find -type d -name '.?*' -prune -o -print
import os

def find(top):

    print(top)
    for (dirpath, dirnames, filenames) in os.walk(top):

        for dirname in dirnames:
            found_dir = os.path.join(dirpath, dirname)
            if dirname.startswith("."):  # if Dir is hidden
                continue

            print(found_dir)


find(top=".")
bin/find.py -type d -name '.?*' -prune -o -print |head -3
.
./bin
./bin/__pycache__
:
:
:
rm -fr dir/ dir.tgz
mkdir -p dir/a/b/c dir/p/q/r
echo hello >dir/a/b/d
echo goodbye > dir/a/b/e
tar czf dir.tgz dir/
:
shell2py tar tvf dir.tgz
import datetime as dt
import os
import tarfile


def tar_list(filepath):
    """List tarred files, a la 'tar tvf'"""

    # Walk to each file or dir found inside

    top = os.path.realpath(os.getcwd())
    with tarfile.open(filepath) as untarring:  # instance of 'tarfile.TarFile'
        names = untarring.getnames()

        for name in names:
            member = untarring.getmember(name)

            # Decline to extract above Top

            outpath = os.path.realpath(name)
            outdir = os.path.dirname(outpath)

            if top != outdir:
                assert outdir.startswith(top + os.sep), (outdir, top)

            # Trace the walk

            print(tar_member_details(member))


def tar_member_details(member):
    """Return such as '-rw-r--r-- jqdoe/staff 8 2021-09-03 20:41 dir/a/b/e'"""

    d_perm = "d" if member.isdir() else "-"
    bits = ((9 * "0") + bin(member.mode)[len("0b") :])[-9:]
    perms = d_perm + "".join("rwxrwxrwx"[_] for _ in range(len(bits)))

    owns = member.uname + os.sep + member.gname
    # TODO: default to ".../..." anonymity, and who extracts to match sender anyhow?

    str_size = str(member.size)
    # TODO: str_size = "." if member.isdir() else str(member.size)

    when = dt.datetime.fromtimestamp(member.mtime)
    stamp = when.strftime("%Y-%m-%d %H:%M")

    name = (member.name + os.sep) if member.isdir() else member.name

    line = "{} {} {} {} {}".format(perms, owns, str_size, stamp, name)

    return line


tar_list("dir.tgz")
bin/tar.py tvf dir.tgz |sed 's,202.-..-.. ..:..,2021-09-03 22:30,'
drwxrwxrwx plavarre/staff 0 2021-09-03 22:30 dir/
drwxrwxrwx plavarre/staff 0 2021-09-03 22:30 dir/a/
drwxrwxrwx plavarre/staff 0 2021-09-03 22:30 dir/p/
drwxrwxrwx plavarre/staff 0 2021-09-03 22:30 dir/p/q/
drwxrwxrwx plavarre/staff 0 2021-09-03 22:30 dir/p/q/r/
drwxrwxrwx plavarre/staff 0 2021-09-03 22:30 dir/a/b/
drwxrwxrwx plavarre/staff 0 2021-09-03 22:30 dir/a/b/c/
-rwxrwxrwx plavarre/staff 6 2021-09-03 22:30 dir/a/b/d
-rwxrwxrwx plavarre/staff 8 2021-09-03 22:30 dir/a/b/e
:
shell2py tar xvkf dir.tgz
import os
import sys
import tarfile


def tar_extract(filepath):
    """Extract tarred files, a la 'tar xvkf'"""

    exists = 0

    # Walk to each file or dir found inside

    top = os.path.realpath(os.getcwd())
    with tarfile.open(filepath) as untarring:  # instance of 'tarfile.TarFile'
        names = untarring.getnames()

        for name in names:
            member = untarring.getmember(name)

            # Decline to extract above Top

            outpath = os.path.realpath(name)
            outdir = os.path.dirname(outpath)

            if top != outdir:
                assert outdir.startswith(top + os.sep), (outdir, top)

            # Trace the walk and make the dirs

            if member.isdir():
                print(name + os.sep)

                if not os.path.isdir(outpath):
                    os.makedirs(outpath)

                continue

            print(name)

            # Skip existing files

            with untarring.extractfile(name) as incoming:

                if os.path.exists(name):
                    stderr_print(
                        "tar.py: {}: Cannot open: File exists".format(name)
                    )
                    exists += 1

                    continue

                # Save the bytes of the member as a file

                member_bytes = incoming.read()
                member_size = len(member_bytes)
                assert member_size == member.size, (member_size, member.size)

                with open(outpath, "wb") as outgoing:
                    outgoing.write(member_bytes)

                # TODO: also extract the perms, stamp, and owns

    if exists:
        stderr_print("tar: Exiting with failure status due to previous errors")
        sys.exit(2)


# deffed in many files  # missing from docs.python.org
def stderr_print(*args, **kwargs):
    """Like Print, but flush don't write Stdout and do write and flush Stderr"""

    sys.stdout.flush()
    print(*args, **kwargs, file=sys.stderr)
    sys.stderr.flush()

    # else caller has to "{}\n".format(...) and flush


tar_extract("dir.tgz")
rm -fr dir/
bin/tar.py xvkf dir.tgz
dir/
dir/a/
dir/p/
dir/p/q/
dir/p/q/r/
dir/a/b/
dir/a/b/c/
dir/a/b/d
dir/a/b/e
bin/tar.py xvkf dir.tgz || echo "+ exit $?"
dir/
dir/a/
dir/p/
dir/p/q/
dir/p/q/r/
dir/a/b/
dir/a/b/c/
dir/a/b/d
tar.py: dir/a/b/d: Cannot open: File exists
dir/a/b/e
tar.py: dir/a/b/e: Cannot open: File exists
tar: Exiting with failure status due to previous errors
+ exit 2
bin/tar.py xvf dir.tgz
dir/
dir/a/
dir/p/
dir/p/q/
dir/p/q/r/
dir/a/b/
dir/a/b/c/
dir/a/b/d
dir/a/b/e
rm -fr dir/ dir.tgz
:
: "TODO: test 'tar' without '-v'"
:
:
