:
:
echo 'for P in bin/*.py; do echo |python3 -m pdb $P; done' |bash
> /Users/plavarre/Public/shell2py/bin/_scraps_.py(1)<module>()
-> """
(Pdb) (Pdb)
> /Users/plavarre/Public/shell2py/bin/dig.py(3)<module>()
-> """
(Pdb) (Pdb)
> /Users/plavarre/Public/shell2py/bin/echo.py(3)<module>()
-> """
(Pdb) (Pdb)
> /Users/plavarre/Public/shell2py/bin/find.py(3)<module>()
-> """
(Pdb) (Pdb)
> /Users/plavarre/Public/shell2py/bin/grep.py(3)<module>()
-> r"""
(Pdb) (Pdb)
> /Users/plavarre/Public/shell2py/bin/less.py(3)<module>()
-> """
(Pdb) (Pdb)
> /Users/plavarre/Public/shell2py/bin/ls.py(3)<module>()
-> """
(Pdb) (Pdb)
> /Users/plavarre/Public/shell2py/bin/scp.py(3)<module>()
-> """
(Pdb) (Pdb)
> /Users/plavarre/Public/shell2py/bin/shell2py.py(3)<module>()
-> """
(Pdb) (Pdb)
> /Users/plavarre/Public/shell2py/bin/ssh.py(3)<module>()
-> """
(Pdb) (Pdb)
> /Users/plavarre/Public/shell2py/bin/tac.py(3)<module>()
-> """
(Pdb) (Pdb)
> /Users/plavarre/Public/shell2py/bin/tar.py(3)<module>()
-> """
(Pdb) (Pdb)
:
:
~/.venvs/pips/bin/black bin/*.py
All done! âœ¨ ðŸ° âœ¨
12 files left unchanged.
:
:
~/.venvs/pips/bin/flake8 --max-line-length=999 --max-complexity 10 --ignore=E203,W503 bin/*.py
:
:
shell2py || echo "+ exit $?"
usage: shell2py.py [-h] VERB [WORD [WORD ...]]
shell2py.py: error: the following arguments are required: VERB
+ exit 2
:
shell2py help || echo "+ exit $?"
shell2py.py: error: argument VERB: invalid choice: 'help' (choose from 'dig', 'echo', 'find', 'grep', 'less', 'ls', 'scp', 'ssh', 'tac', 'tar')
+ exit 2
:
shell2py -h
usage: shell2py.py [-h] VERB [WORD [WORD ...]]

say in Python what you said in Shell

positional arguments:
  VERB        the first word of a Shell line, being the program to run
  WORD        another word of a Shell line, being an arg of the program to run

optional arguments:
  -h, --help  show this help message and exit

examples:
  shell2py -h  # show this help message and exit
  ls.py -1  # show the files and dirs inside a dir
  shell2py ls -1  # show how to say 'ls -1' in Python
  echo.py a 'b c'  # show some words
  shell2py echo a 'b c'  # show how your Shell splits apart the chars you're typing
  ls bin/*  # show the verbs of Bash that this revision of Shell2Py will explain
:
shell2py --help
usage: shell2py.py [-h] VERB [WORD [WORD ...]]

say in Python what you said in Shell

positional arguments:
  VERB        the first word of a Shell line, being the program to run
  WORD        another word of a Shell line, being an arg of the program to run

optional arguments:
  -h, --help  show this help message and exit

examples:
  shell2py -h  # show this help message and exit
  ls.py -1  # show the files and dirs inside a dir
  shell2py ls -1  # show how to say 'ls -1' in Python
  echo.py a 'b c'  # show some words
  shell2py echo a 'b c'  # show how your Shell splits apart the chars you're typing
  ls bin/*  # show the verbs of Bash that this revision of Shell2Py will explain
:
:
shell2py ls --help
usage: ls.py [--help] [-1 | -l | -C] [--headings] [--full-time] [-X | -f] [-a]
             [-d] [-F]
             [TOP ...]

show the files and dirs inside some dirs

positional arguments:
  TOP              a file or dir to show (default: show '.' current dir)

optional arguments:
  --help           show this help message and exit
  -1               show one name per line
  -l               show details of perms, links, user, group, bytes, stamp, name
  -C               show columns of names (default: True)
  --headings       insert a row of headings before the rows of '-l' details
  --full-time      stamp with a more precise date/time in the rows of '-l' details
  -X               sort by ext (default: sort by name)
  -f               do not sort
  -a, --all        hide no names (by showing the names that start with the '.' dot)
  -d, --directory  show the names of dirs (not the files and dirs inside)
  -F, --classify   add '*/=>@' suffixes to exec, dir, socket, door, or sym

quirks:
  shows columns like Linux, separated by two spaces, not equal width like Mac
  quits at first top found, doesn't show all not found like Linux or Mac
  shows user and group as "." dot when same as $HOME
  actually doesn't yet know how to mark socket as '=', nor door as '>'
  writes less code when given just dirs, or just files, or just one top

examples:
  ls.py --help  # show this help message and exit
  ls -1  # show each file or dir inside the current dir
  ls -C  # ask explicitly for the default output
  ls *  # show each file, then show each file or dir inside each child dir
:
shell2py ls Makefile
import os


def one_name_ls(name):

    _ = os.stat(name)
    print(name)


one_name_ls("Makefile")
bin/ls.py Makefile
Makefile
:
shell2py ls -1
import os

names = os.listdir()
names = list(_ for _ in names if not _.startswith("."))

for name in sorted(names):
    print(name)
bin/ls.py -1
Makefile
README.md
bin
make.log
:
shell2py ls -1 .
import os


def one_dir_ls(top):

    names = os.listdir(top)
    names = list(_ for _ in names if not _.startswith("."))

    for name in sorted(names):
        print(name)


one_dir_ls(".")
bin/ls.py -1 .
Makefile
README.md
bin
make.log
:
shell2py ls -1a
import os

names = list([os.curdir, os.pardir] + os.listdir())

for name in sorted(names):
    print(name)
bin/ls.py -1a
.
..
.git
Makefile
README.md
bin
make.log
:
shell2py ls
import argparse
import os


def one_dir_ls():

    names = os.listdir()
    names = list(_ for _ in names if not _.startswith("."))

    # Choose an order of names

    cells = sorted(names)

    # Guess the width of the Terminal

    tty_size = argparse.Namespace(columns=80, lines=24)  # classic Terminal
    try:
        tty_size = os.get_terminal_size()
    except OSError:
        pass  # such as Stdout redirected to file

    tty_columns = tty_size.columns

    # Pack names into columns

    chars = pack_cells_in_columns(cells, tty_columns=tty_columns, sep="  ")
    if chars:
        print(chars)


def pack_cells_in_columns(cells, tty_columns, sep):
    """Pack Cells into Columns with Sep's between them"""

    strs = list(str(_) for _ in cells)

    # Search for the shortest Matrix Height that fits Cells into the Tty Columns

    shafts = list()
    columns_by_x = list()

    if strs:
        len_strs = len(strs)
        for max_y in range(len_strs + 1):
            assert max_y < len_strs

            matrix_height = max_y + 1
            matrix_width = (len_strs + matrix_height - 1) // matrix_height
            assert (matrix_width * matrix_height) >= len_strs

            shafts = list()
            for x in range(matrix_width):
                shaft = strs[(x * matrix_height) :][:matrix_height]
                shaft = (shaft + (matrix_height * [""]))[:matrix_height]
                shafts.append(shaft)

            columns_by_x = list()
            for shaft in shafts:
                shaft_columns = max(len(_) for _ in shaft)
                columns_by_x.append(shaft_columns)

            matrix_columns = sum(columns_by_x)
            matrix_columns += (matrix_width - 1) * len(sep)

            if matrix_columns < tty_columns:

                break

    # Join the Chars

    floors = tuple(zip(*shafts))  # Python 'zip(*' transposes NxN square matrices

    lines = list()
    for (y, floor) in enumerate(floors):
        assert len(floor) == len(columns_by_x)
        line = sep.join(f.ljust(c) for (f, c) in zip(floor, columns_by_x))
        lines.append(line)

    # Succeed

    chars = "\n".join(lines)

    return chars


one_dir_ls()
bin/ls.py
Makefile  README.md  bin  make.log
bin/ls.py bin/
__pycache__  dig.py   find.py  less.py  scp.py    shell2py.py  tac.py
_scraps_.py  echo.py  grep.py  ls.py    shell2py  ssh.py       tar.py
:
shell2py ls -1d *
import os


def some_tops_ls(tops):

    for top in tops:
        _ = os.stat(top)
    some_names_ls(names=tops)


def some_names_ls(names):
    for name in sorted(names):
        print(name)


some_tops_ls(["Makefile", "README.md", "bin", "make.log"])
bin/ls.py -1d *
Makefile
README.md
bin
make.log
bin/ls.py *
Makefile  README.md  make.log

bin:
__pycache__  dig.py   find.py  less.py  scp.py    shell2py.py  tac.py
_scraps_.py  echo.py  grep.py  ls.py    shell2py  ssh.py       tar.py
:
shell2py ls -1F *
import os
import stat


def some_tops_ls(topfiles, topdirs):

    topfiles_stats = dict()
    for topfile in topfiles:
        topfiles_stats[topfile] = os.stat(topfile)
    some_stats_ls(stats=topfiles_stats)

    for (index, topdir) in enumerate(topdirs):
        print()
        print("{}:".format(topdir))
        names = os.listdir(topdir)
        names = list(_ for _ in names if not _.startswith("."))

        topdir_sub_stats = {_: os.stat(os.path.join(topdir, _)) for _ in names}
        some_stats_ls(stats=topdir_sub_stats)


def some_stats_ls(stats):
    for item in sorted(stats.items()):
        stats_item_print(item)


def stats_item_print(item):

    marked_name = stats_item_format(item)
    print(marked_name)


def stats_item_format(item):

    (item_name, item_stat) = item
    st_mode = item_stat.st_mode

    filemode = stat.filemode(st_mode)
    islnk = stat.S_ISLNK(st_mode)

    if filemode.startswith("d"):
        mark = "/"
    elif "x" in filemode:
        mark = "*"
    elif islnk:
        mark = "@"  # TODO: pass tests of this
    else:
        mark = ""  # wrong mark when it should be socket as '=', or door as '>'

    marked_name = item_name + mark

    return marked_name


some_tops_ls(["Makefile", "README.md", "make.log"], topdirs=["bin"])
bin/ls.py -1F *
Makefile
README.md
make.log

bin:
__pycache__/
_scraps_.py
dig.py*
echo.py*
find.py*
grep.py*
less.py*
ls.py*
scp.py*
shell2py*
shell2py.py*
ssh.py*
tac.py*
tar.py*
bin/ls.py -F *
Makefile  README.md  make.log

bin:
__pycache__/  dig.py*   find.py*  less.py*  scp.py*    shell2py.py*  tac.py*
_scraps_.py   echo.py*  grep.py*  ls.py*    shell2py*  ssh.py*       tar.py*
:
:
shell2py echo 'Hello, Echo World!'
import sys

# echo.py 'Hello, Echo World!'
sys.argv = ["echo.py", "Hello, Echo World!"]  # unwanted if trying to echo a command line

sys.stderr.flush()  # unneeded if not also writing Stderr
print(*sys.argv[1:])
sys.stdout.flush()  # unneeded if exiting now
bin/echo.py 'Hello, Echo World!'
Hello, Echo World!
:
shell2py echo --v 'Hello,' 'Echo World!'
import sys

# echo.py Hello, 'Echo World!'
sys.argv = ["echo.py", "Hello,", "Echo World!"]  # unwanted if trying to echo a command line

for (index, arg) in enumerate(sys.argv):
    if index:
        print("{}: {!r}".format(index, arg))
bin/echo.py --v 'Hello,' 'Echo World!'
1: 'Hello,'
2: 'Echo World!'
:
shell2py echo -n 'âŒƒ âŒ¥ â‡§ âŒ˜ â† â†’ â†“ â†‘ âŽ‹ â‡¥ â‹®'
import sys

# echo.py 'âŒƒ âŒ¥ â‡§ âŒ˜ â† â†’ â†“ â†‘ âŽ‹ â‡¥ â‹®'
sys.argv = ["echo.py", "âŒƒ âŒ¥ â‡§ âŒ˜ â† â†’ â†“ â†‘ âŽ‹ â‡¥ â‹®"]  # unwanted if trying to echo a command line

sys.stderr.flush()  # unneeded if not also writing Stderr
sys.stdout.write(" ".join(sys.argv[1:]))  # tada, no line break
sys.stdout.flush()  # unneeded if exiting now
bin/echo.py -n 'âŒƒ âŒ¥ â‡§ âŒ˜ â† â†’ â†“ â†‘ âŽ‹ â‡¥ â‹®' |hexdump -C
00000000  e2 8c 83 20 e2 8c a5 20  e2 87 a7 20 e2 8c 98 20  |... ... ... ... |
00000010  e2 86 90 20 e2 86 92 20  e2 86 93 20 e2 86 91 20  |... ... ... ... |
00000020  e2 8e 8b 20 e2 87 a5 20  e2 8b ae                 |... ... ...|
0000002b
:
:
rm -fr dotdir/ dir/
:
mkdir -p .dotdir/
touch .dotdir/.dotdir-dotchild
touch .dotdir/dotdir-child
mkdir -p dir/
touch dir/.dir-dotchild
touch dir/dir-child
:
rm -fr file
:
shell2py find -maxdepth 1 -type d
import os

def find(top):
    """find -maxdepth 1 -type d"""

    print(top)
    for (dirpath, dirnames, filenames) in os.walk(top):

        depth = 1 + dirpath.count(os.sep)
        if depth > 1:
            continue

        dirnames[:] = sorted(dirnames)
        for dirname in dirnames:
            found_dir = os.path.join(dirpath, dirname)
            print(found_dir)

find(top=".")
bin/find.py -maxdepth 1 -type d |grep i
./.dotdir
./.git
./bin
./dir
:
shell2py find -name '.?*'
import os

def find(top):
    """find -name '.?*'"""

    print(top)
    for (dirpath, dirnames, filenames) in os.walk(top):

        dirnames[:] = list(_ for _ in dirnames if _.startswith("."))
        dirnames[:] = sorted(dirnames)
        for dirname in dirnames:
            found_dir = os.path.join(dirpath, dirname)
            print(found_dir)

        filenames[:] = list(_ for _ in filenames if _.startswith("."))
        filenames[:] = sorted(filenames)
        for filename in filenames:
            found_file = os.path.join(dirpath, filename)
            print(found_file)

find(top=".")
bin/find.py -name '.?*' >file
head -4 file
.
./.dotdir
./.git
./.dotdir/.dotdir-dotchild
:
shell2py find -name '.?*' -prune -o -print
import os

def find(top):
    """find -name '.?*' -prune -o -print"""

    print(top)
    for (dirpath, dirnames, filenames) in os.walk(top):

        dirnames[:] = list(_ for _ in dirnames if not _.startswith("."))
        dirnames[:] = sorted(dirnames)
        for dirname in dirnames:
            found_dir = os.path.join(dirpath, dirname)
            print(found_dir)

        filenames[:] = list(_ for _ in filenames if not _.startswith("."))
        filenames[:] = sorted(filenames)
        for filename in filenames:
            found_file = os.path.join(dirpath, filename)
            print(found_file)

find(top=".")
bin/find.py -name '.?*' -prune -o -print >file
head -10 file
.
./bin
./dir
./Makefile
./README.md
./file
./make.log
./bin/__pycache__
./bin/_scraps_.py
./bin/dig.py
:
shell2py find -type d
import os

def find(top):
    """find -type d"""

    print(top)
    for (dirpath, dirnames, filenames) in os.walk(top):

        dirnames[:] = sorted(dirnames)
        for dirname in dirnames:
            found_dir = os.path.join(dirpath, dirname)
            print(found_dir)

find(top=".")
bin/find.py -type d >file
head -10 file
.
./.dotdir
./.git
./bin
./dir
./.git/hooks
./.git/info
./.git/logs
./.git/objects
./.git/refs
:
shell2py find -name '.?*' -prune -o -type d -print
import os

def find(top):
    """find -name '.?*' -prune -o -type d -print"""

    print(top)
    for (dirpath, dirnames, filenames) in os.walk(top):

        dirnames[:] = list(_ for _ in dirnames if not _.startswith("."))
        dirnames[:] = sorted(dirnames)
        for dirname in dirnames:
            found_dir = os.path.join(dirpath, dirname)
            print(found_dir)

find(top=".")
bin/find.py -name '.?*' -prune -o -type d -print >file
head -10 file
.
./bin
./dir
./bin/__pycache__
:
rm -fr file
:
:
:
rm -fr file
:
shell2py grep.py -anw 'def|jkl|pqr'
import os
import re
import sys

def grep(pyregex):

    fd = sys.stdout.fileno()
    lines = 0
    while True:
        line = sys.stdin.buffer.readline()
        if not line:

            break

        lines += 1
        if re.search(pyregex, string=line):

            data = str(lines).encode() + b":" + line
            os.write(fd, data)

grep(rb"\b(def|jkl|pqr)\b")
:
echo -n 'abc@def ghi@jklmno@pqr stu@vwx' |tr '@' '\n' >file && hexdump -C file
00000000  61 62 63 0a 64 65 66 20  67 68 69 0a 6a 6b 6c 6d  |abc.def ghi.jklm|
00000010  6e 6f 0a 70 71 72 20 73  74 75 0a 76 77 78        |no.pqr stu.vwx|
0000001e
cat file |grep.py -anw 'def|jkl|pqr'
2:def ghi
4:pqr stu
cat file |grep.py -aw 'def|jkl|pqr'
def ghi
pqr stu
cat file |grep.py -a 'def|jkl|pqr'
def ghi
jklmno
pqr stu
(cat file |grep.py 'def|jkl|pqr') || echo "+ exit $?"
grep.py: error: choose argument -a
+ exit 2
:
rm -fr file
:
:
shell2py less -FIXR
import shlex
import subprocess
import sys

shline = "less -FIXR"
run = subprocess.run(shlex.split("less -FIXR"), shell=False)

if run.returncode:
    sys.stderr.write("+ exit {}\n".format(run.returncode))
    sys.exit(run.returncode)
:
ls |less.py -FIXR  # hangs at screens of less than 6 lines
Makefile
README.md
bin
dir
make.log
:
:
shell2py tac -
import sys


def tac_file(file):

    with open(file) as reading:
        isatty = reading.isatty()

        if isatty:
            sys.stderr.write("Press âŒƒD EOF to quit\n")

        lines = reading.readlines()

    if isatty:
        sys.stderr.write("\n")

    for line in lines[::-1]:
        sys.stdout.write(line)


files = ["/dev/stdin"]
for file in files:
    tac_file(file)
bash -c 'echo A; echo B; echo C; echo -n Z' |bin/tac.py -
ZC
B
A
:
:
:
rm -fr dir/ dir.tgz
:
mkdir -p dir/a/b/c dir/p/q/r
echo hello >dir/a/b/d
echo goodbye > dir/a/b/e
bin/tar.py czf dir.tgz dir/
:
:
shell2py tar tvf dir.tgz
import datetime as dt
import os
import tarfile


def tar_list(filepath):
    """List tarred files, a la 'tar tvf'"""

    # Visit each Dir or File

    top = os.path.realpath(os.getcwd())
    with tarfile.open(filepath) as untarring:  # instance of 'tarfile.TarFile'
        names = untarring.getnames()

        for name in names:
            member = untarring.getmember(name)

            # Skip the Dir or File if not at or below Top

            outpath = os.path.realpath(name)
            outdir = os.path.dirname(outpath)

            if top != outdir:
                assert outdir.startswith(top + os.sep), (outdir, top)

            # Trace the walk

            print(tar_member_details(member))


def tar_member_details(member):
    """Return such as '-rw-r--r-- jqdoe/staff 8 2021-09-03 20:41 dir/a/b/e'"""

    d_perm = "d" if member.isdir() else "-"
    bits = ((9 * "0") + bin(member.mode)[len("0b") :])[-9:]
    perms = d_perm + "".join("rwxrwxrwx"[_] for _ in range(len(bits)))

    member_uname = "..."  # ellipsis "..." is more anonymous than "member.uname"
    member_gname = "..."  # ellipsis "..." is more anonymous than "member.gname"
    owns = member_uname + os.sep + member_gname

    str_size = "." if member.isdir() else str(member.size)  # 0 at dirs is meaningless

    when = dt.datetime.fromtimestamp(member.mtime)
    stamp = when.strftime("%Y-%m-%d %H:%M")

    name = (member.name + os.sep) if member.isdir() else member.name

    line = "{} {} {} {} {}".format(perms, owns, str_size, stamp, name)

    return line


tar_list("dir.tgz")
bin/tar.py tvf dir.tgz |sed 's,202.-..-.. ..:..,2021-09-11 11:30,'
drwxrwxrwx .../... . 2021-09-11 11:30 dir/
drwxrwxrwx .../... . 2021-09-11 11:30 dir/a/
drwxrwxrwx .../... . 2021-09-11 11:30 dir/p/
drwxrwxrwx .../... . 2021-09-11 11:30 dir/p/q/
drwxrwxrwx .../... . 2021-09-11 11:30 dir/p/q/r/
drwxrwxrwx .../... . 2021-09-11 11:30 dir/a/b/
drwxrwxrwx .../... . 2021-09-11 11:30 dir/a/b/c/
-rwxrwxrwx .../... 6 2021-09-11 11:30 dir/a/b/d
-rwxrwxrwx .../... 8 2021-09-11 11:30 dir/a/b/e
:
shell2py tar xvkf dir.tgz
import os
import sys
import tarfile


def tar_extract(filepath):
    """Extract tarred files, a la 'tar xvkf'"""

    exists = list()

    # Walk to each file or dir found inside

    top = os.path.realpath(os.getcwd())
    with tarfile.open(filepath) as untarring:  # instance of 'tarfile.TarFile'
        names = untarring.getnames()

        for name in names:
            member = untarring.getmember(name)

            # Skip the Dir or File if not at or below Top

            outpath = os.path.realpath(name)
            outdir = os.path.dirname(outpath)

            if top != outdir:
                assert outdir.startswith(top + os.sep), (outdir, top)

            # Trace the walk and make the Dirs

            if member.isdir():
                stderr_print(name + os.sep)

                if not os.path.isdir(outpath):
                    os.makedirs(outpath)

                continue

            stderr_print(name)

            # Visit each Dir or File

            with untarring.extractfile(name) as incoming:

                # Skip File's created before now

                if os.path.exists(name):
                    stderr_print(
                        "tar.py: {}: Cannot open: File exists".format(name)
                    )
                    exists.append(name)

                    continue

                # Fetch the bytes of the Member

                member_bytes = incoming.read()
                member_size = len(member_bytes)
                assert member_size == member.size, (member_size, member.size)

                # Write the bytes as a separate File

                with open(outpath, "wb") as outgoing:
                    outgoing.write(member_bytes)

                # : also extract the Perms and Stamp, but not so much the Owns

    if exists:
        stderr_print("tar: Exiting with failure status due to previous errors")
        sys.exit(2)


# deffed in many files  # missing from docs.python.org
def stderr_print(*args, **kwargs):
    """Like Print, but flush don't write Stdout and do write and flush Stderr"""

    sys.stdout.flush()
    print(*args, **kwargs, file=sys.stderr)
    sys.stderr.flush()

    # else caller has to "{}\n".format(...) and flush


tar_extract("dir.tgz")
rm -fr dir/
bin/tar.py xvkf dir.tgz
dir/
dir/a/
dir/p/
dir/p/q/
dir/p/q/r/
dir/a/b/
dir/a/b/c/
dir/a/b/d
dir/a/b/e
bin/tar.py xvkf dir.tgz || echo "+ exit $?"
dir/
dir/a/
dir/p/
dir/p/q/
dir/p/q/r/
dir/a/b/
dir/a/b/c/
dir/a/b/d
tar.py: dir/a/b/d: Cannot open: File exists
dir/a/b/e
tar.py: dir/a/b/e: Cannot open: File exists
tar: Exiting with failure status due to previous errors
+ exit 2
:
shell2py tar xvf dir.tgz
import os
import sys
import tarfile


def tar_extract(filepath):
    """Extract tarred files, a la 'tar xvf'"""

    # Walk to each file or dir found inside

    top = os.path.realpath(os.getcwd())
    with tarfile.open(filepath) as untarring:  # instance of 'tarfile.TarFile'
        names = untarring.getnames()

        for name in names:
            member = untarring.getmember(name)

            # Skip the Dir or File if not at or below Top

            outpath = os.path.realpath(name)
            outdir = os.path.dirname(outpath)

            if top != outdir:
                assert outdir.startswith(top + os.sep), (outdir, top)

            # Trace the walk and make the Dirs

            if member.isdir():
                stderr_print(name + os.sep)

                if not os.path.isdir(outpath):
                    os.makedirs(outpath)

                continue

            stderr_print(name)

            # Visit each Dir or File

            with untarring.extractfile(name) as incoming:

                # Fetch the bytes of the Member

                member_bytes = incoming.read()
                member_size = len(member_bytes)
                assert member_size == member.size, (member_size, member.size)

                # Write the bytes as a separate File

                with open(outpath, "wb") as outgoing:
                    outgoing.write(member_bytes)

                # : also extract the Perms and Stamp, but not so much the Owns


# deffed in many files  # missing from docs.python.org
def stderr_print(*args, **kwargs):
    """Like Print, but flush don't write Stdout and do write and flush Stderr"""

    sys.stdout.flush()
    print(*args, **kwargs, file=sys.stderr)
    sys.stderr.flush()

    # else caller has to "{}\n".format(...) and flush


tar_extract("dir.tgz")
bin/tar.py xvf dir.tgz
dir/
dir/a/
dir/p/
dir/p/q/
dir/p/q/r/
dir/a/b/
dir/a/b/c/
dir/a/b/d
dir/a/b/e
:
:
shell2py tar tf dir.tgz
import os
import tarfile


def tar_list(filepath):
    """List tarred files, a la 'tar tf'"""

    # Visit each Dir or File

    top = os.path.realpath(os.getcwd())
    with tarfile.open(filepath) as untarring:  # instance of 'tarfile.TarFile'
        names = untarring.getnames()

        for name in names:
            member = untarring.getmember(name)

            # Skip the Dir or File if not at or below Top

            outpath = os.path.realpath(name)
            outdir = os.path.dirname(outpath)

            if top != outdir:
                assert outdir.startswith(top + os.sep), (outdir, top)

            # Trace the walk

            if member.isdir():
                print(name + os.sep)
            else:
                print(name)


tar_list("dir.tgz")
bin/tar.py tf dir.tgz
dir/
dir/a/
dir/p/
dir/p/q/
dir/p/q/r/
dir/a/b/
dir/a/b/c/
dir/a/b/d
dir/a/b/e
:
shell2py tar xkf dir.tgz
import os
import sys
import tarfile


def tar_extract(filepath):
    """Extract tarred files, a la 'tar xkf'"""

    exists = list()

    # Walk to each file or dir found inside

    top = os.path.realpath(os.getcwd())
    with tarfile.open(filepath) as untarring:  # instance of 'tarfile.TarFile'
        names = untarring.getnames()

        for name in names:
            member = untarring.getmember(name)

            # Skip the Dir or File if not at or below Top

            outpath = os.path.realpath(name)
            outdir = os.path.dirname(outpath)

            if top != outdir:
                assert outdir.startswith(top + os.sep), (outdir, top)

            # Make the Dirs

            if member.isdir():

                if not os.path.isdir(outpath):
                    os.makedirs(outpath)

                continue

            # Visit each Dir or File

            with untarring.extractfile(name) as incoming:

                # Skip File's created before now

                if os.path.exists(name):
                    stderr_print(
                        "tar.py: {}: Cannot open: File exists".format(name)
                    )
                    exists.append(name)

                    continue

                # Fetch the bytes of the Member

                member_bytes = incoming.read()
                member_size = len(member_bytes)
                assert member_size == member.size, (member_size, member.size)

                # Write the bytes as a separate File

                with open(outpath, "wb") as outgoing:
                    outgoing.write(member_bytes)

                # : also extract the Perms and Stamp, but not so much the Owns

    if exists:
        stderr_print("tar: Exiting with failure status due to previous errors")
        sys.exit(2)


# deffed in many files  # missing from docs.python.org
def stderr_print(*args, **kwargs):
    """Like Print, but flush don't write Stdout and do write and flush Stderr"""

    sys.stdout.flush()
    print(*args, **kwargs, file=sys.stderr)
    sys.stderr.flush()

    # else caller has to "{}\n".format(...) and flush


tar_extract("dir.tgz")
rm -fr dir/
bin/tar.py xkf dir.tgz
bin/tar.py xkf dir.tgz || echo "+ exit $?"
tar.py: dir/a/b/d: Cannot open: File exists
tar.py: dir/a/b/e: Cannot open: File exists
tar: Exiting with failure status due to previous errors
+ exit 2
:
shell2py tar xf dir.tgz
import os
import tarfile


def tar_extract(filepath):
    """Extract tarred files, a la 'tar xf'"""

    # Walk to each file or dir found inside

    top = os.path.realpath(os.getcwd())
    with tarfile.open(filepath) as untarring:  # instance of 'tarfile.TarFile'
        names = untarring.getnames()

        for name in names:
            member = untarring.getmember(name)

            # Skip the Dir or File if not at or below Top

            outpath = os.path.realpath(name)
            outdir = os.path.dirname(outpath)

            if top != outdir:
                assert outdir.startswith(top + os.sep), (outdir, top)

            # Make the Dirs

            if member.isdir():

                if not os.path.isdir(outpath):
                    os.makedirs(outpath)

                continue

            # Visit each Dir or File

            with untarring.extractfile(name) as incoming:

                # Fetch the bytes of the Member

                member_bytes = incoming.read()
                member_size = len(member_bytes)
                assert member_size == member.size, (member_size, member.size)

                # Write the bytes as a separate File

                with open(outpath, "wb") as outgoing:
                    outgoing.write(member_bytes)

                # : also extract the Perms and Stamp, but not so much the Owns


tar_extract("dir.tgz")
bin/tar.py xf dir.tgz
:
:
rm -fr p.py
:
shell2py tar tf dir.tgz dir/a
import fnmatch
import os
import sys
import tarfile


def tar_list(filepath, patterns):
    """List tarred files, a la 'tar -tf dir/a'"""

    fnmatches = tar_fnmatches_open(patterns)

    # Visit each Dir or File

    top = os.path.realpath(os.getcwd())
    with tarfile.open(filepath) as untarring:  # instance of 'tarfile.TarFile'
        names = untarring.getnames()

        for name in names:
            member = untarring.getmember(name)

            # Skip the Dir or File if not at or below Pattern

            if not tar_fnmatches_find_name(fnmatches, name=name):
                continue

            # Skip the Dir or File if not at or below Top

            outpath = os.path.realpath(name)
            outdir = os.path.dirname(outpath)

            if top != outdir:
                assert outdir.startswith(top + os.sep), (outdir, top)

            # Trace the walk

            if member.isdir():
                print(name + os.sep)
            else:
                print(name)

    misses = tar_fnmatches_close(fnmatches)
    if misses:
        sys.exit(1)


def tar_fnmatches_open(patterns):
    """Starting counting fnmatch'es"""

    fnmatches = dict()
    for pat in patterns:
        fnmatches[pat] = 0

    return fnmatches


def tar_fnmatches_find_name(fnmatches, name):
    """Count fnmatch'es found, if any"""

    count = 0
    for pat in fnmatches.keys():

        at_or_below_pat = False
        name_or_above = name
        while name_or_above:
            if fnmatch.fnmatchcase(name_or_above, pat=pat):
                at_or_below_pat = True
                break
            name_or_above = os.path.dirname(name_or_above)

        if at_or_below_pat:
            fnmatches[pat] += 1

            count += 1

    return count


def tar_fnmatches_close(fnmatches):
    """Count each Pattern not found, and trace it too"""

    count = 0
    for (pat, hits) in fnmatches.items():
        if not hits:
            stderr_print("tar: {}: Not found in archive".format(pat))
            count += 1

            # Mac and Linux rstrip 1 or all of the trailing '/' slashes in a Pattern

    return count


# deffed in many files  # missing from docs.python.org
def stderr_print(*args, **kwargs):
    """Like Print, but flush don't write Stdout and do write and flush Stderr"""

    sys.stdout.flush()
    print(*args, **kwargs, file=sys.stderr)
    sys.stderr.flush()

    # else caller has to "{}\n".format(...) and flush


tar_list("dir.tgz", patterns=["dir/a"])
bin/tar.py tf dir.tgz dir/a
dir/a/
dir/a/b/
dir/a/b/c/
dir/a/b/d
dir/a/b/e
:
shell2py tar tf dir.tgz dir dir/a// dir >p.py
tail -2 p.py

tar_list("dir.tgz", patterns=["dir", "dir/a", "dir"])
bin/tar.py tf dir.tgz dir dir/a/b/d/// dir
dir/
dir/a/
dir/p/
dir/p/q/
dir/p/q/r/
dir/a/b/
dir/a/b/c/
dir/a/b/d
dir/a/b/e
:
shell2py tar xf dir.tgz -O 'dir/a/*/?' >p.py
tail -2 p.py

tar_extract("dir.tgz", patterns=["dir/a/*/?"])
bin/tar.py xf dir.tgz -O 'dir/a/*/?'
hello
goodbye
:
:
rm -fr dir/ dir.tgz p.py
:
:
:
:
git ls-files
Makefile
README.md
bin/_scraps_.py
bin/dig.py
bin/echo.py
bin/find.py
bin/grep.py
bin/less.py
bin/ls.py
bin/scp.py
bin/shell2py
bin/shell2py.py
bin/ssh.py
bin/tac.py
bin/tar.py
make.log
git status --short --ignored |grep -v '^ M ' |(grep '[.]py$' || :)
:
:
: copied by: git clone https://github.com/pelavarre/shell2py.git
rm -fr .dotfile .dotdir/ dir/ dir.tgz file p.py
rm -fr bin/__pycache__/
