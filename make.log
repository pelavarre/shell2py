:
:
echo 'for P in bin/*.py; do echo |python3 -m pdb $P; done' |bash
> /Users/plavarre/Public/shell2py/bin/_scraps_.py(1)<module>()
-> """
(Pdb) (Pdb)
> /Users/plavarre/Public/shell2py/bin/dig.py(3)<module>()
-> """
(Pdb) (Pdb)
> /Users/plavarre/Public/shell2py/bin/echo.py(3)<module>()
-> """
(Pdb) (Pdb)
> /Users/plavarre/Public/shell2py/bin/find.py(3)<module>()
-> """
(Pdb) (Pdb)
> /Users/plavarre/Public/shell2py/bin/grep.py(3)<module>()
-> r"""
(Pdb) (Pdb)
> /Users/plavarre/Public/shell2py/bin/less.py(3)<module>()
-> """
(Pdb) (Pdb)
> /Users/plavarre/Public/shell2py/bin/ls.py(3)<module>()
-> """
(Pdb) (Pdb)
> /Users/plavarre/Public/shell2py/bin/scp.py(3)<module>()
-> """
(Pdb) (Pdb)
> /Users/plavarre/Public/shell2py/bin/shell2py.py(3)<module>()
-> """
(Pdb) (Pdb)
> /Users/plavarre/Public/shell2py/bin/ssh.py(3)<module>()
-> """
(Pdb) (Pdb)
> /Users/plavarre/Public/shell2py/bin/tac.py(3)<module>()
-> """
(Pdb) (Pdb)
> /Users/plavarre/Public/shell2py/bin/tar.py(3)<module>()
-> """
(Pdb) (Pdb)
:
:
~/.venvs/pips/bin/black bin/*.py
All done! âœ¨ ðŸ° âœ¨
12 files left unchanged.
:
:
~/.venvs/pips/bin/flake8 --max-line-length=999 --max-complexity 10 --ignore=E203,W503 bin/*.py
:
:
shell2py || echo "+ exit $?"
usage: shell2py.py [-h] VERB [WORD [WORD ...]]
shell2py.py: error: the following arguments are required: VERB
+ exit 2
:
shell2py help || echo "+ exit $?"
shell2py.py: error: argument VERB: invalid choice: 'help' (choose from 'dig', 'echo', 'find', 'grep', 'less', 'ls', 'scp', 'ssh', 'tac', 'tar')
+ exit 2
:
shell2py -h
usage: shell2py.py [-h] VERB [WORD [WORD ...]]

say in Python what you said in Shell

positional arguments:
  VERB        the first word of a Shell line, being the program to run
  WORD        another word of a Shell line, being an arg of the program to run

optional arguments:
  -h, --help  show this help message and exit

examples:
  shell2py -h  # show this help message and exit
  ls.py -1  # show the files and dirs inside a dir
  shell2py ls -1  # show how to say 'ls -1' in Python
  echo.py a 'b c'  # show some words
  shell2py echo a 'b c'  # show how your Shell splits apart the chars you're typing
  ls bin/*  # show the verbs of Bash that this revision of Shell2Py will explain
:
shell2py --help
usage: shell2py.py [-h] VERB [WORD [WORD ...]]

say in Python what you said in Shell

positional arguments:
  VERB        the first word of a Shell line, being the program to run
  WORD        another word of a Shell line, being an arg of the program to run

optional arguments:
  -h, --help  show this help message and exit

examples:
  shell2py -h  # show this help message and exit
  ls.py -1  # show the files and dirs inside a dir
  shell2py ls -1  # show how to say 'ls -1' in Python
  echo.py a 'b c'  # show some words
  shell2py echo a 'b c'  # show how your Shell splits apart the chars you're typing
  ls bin/*  # show the verbs of Bash that this revision of Shell2Py will explain
:
:
shell2py ls || echo "+ exit $?"
usage: ls.py [--help] [-1]
ls.py: error: need stronger translator, meanwhile the 'ls.py --help' examples do work
+ exit 3
:
shell2py ls --help
usage: ls.py [--help] [-1]

show the files and dirs inside a dir

optional arguments:
  --help  show this help message and exit
  -1      print one filename or dirname per line

quirks:
  you must choose '-1' or '-l', because default 'ls' style needs 'os.get_terminal_size'

examples:
  ls.py --help  # show this help message and exit
  ls -1  # name each file or dir inside the current dir
:
shell2py ls -1 |cat -n |expand |sed 's,  *$,,'
     1  import os
     2
     3  filenames = sorted(os.listdir())
     4  for filename in filenames:
     5      if not filename.startswith("."):  # if not hidden
     6          print(filename)
bin/ls.py -1
Makefile
README.md
bin
make.log
:
:
shell2py echo 'Hello, Echo World!'
import sys

# echo.py 'Hello, Echo World!'
sys.argv = ["echo.py", "Hello, Echo World!"]  # unwanted if trying to echo a command line

sys.stderr.flush()  # unneeded if not also writing Stderr
print(*sys.argv[1:])
sys.stdout.flush()  # unneeded if exiting now
bin/echo.py 'Hello, Echo World!'
Hello, Echo World!
:
shell2py echo --v 'Hello,' 'Echo World!'
import sys

# echo.py Hello, 'Echo World!'
sys.argv = ["echo.py", "Hello,", "Echo World!"]  # unwanted if trying to echo a command line

for (index, arg) in enumerate(sys.argv):
    if index:
        print("{}: {!r}".format(index, arg))
bin/echo.py --v 'Hello,' 'Echo World!'
1: 'Hello,'
2: 'Echo World!'
:
shell2py echo -n 'âŒƒ âŒ¥ â‡§ âŒ˜ â† â†’ â†“ â†‘ âŽ‹ â‡¥ â‹®'
import sys

# echo.py 'âŒƒ âŒ¥ â‡§ âŒ˜ â† â†’ â†“ â†‘ âŽ‹ â‡¥ â‹®'
sys.argv = ["echo.py", "âŒƒ âŒ¥ â‡§ âŒ˜ â† â†’ â†“ â†‘ âŽ‹ â‡¥ â‹®"]  # unwanted if trying to echo a command line

sys.stderr.flush()  # unneeded if not also writing Stderr
sys.stdout.write(" ".join(sys.argv[1:]))  # tada, no line break
sys.stdout.flush()  # unneeded if exiting now
bin/echo.py -n 'âŒƒ âŒ¥ â‡§ âŒ˜ â† â†’ â†“ â†‘ âŽ‹ â‡¥ â‹®' |hexdump -C
00000000  e2 8c 83 20 e2 8c a5 20  e2 87 a7 20 e2 8c 98 20  |... ... ... ... |
00000010  e2 86 90 20 e2 86 92 20  e2 86 93 20 e2 86 91 20  |... ... ... ... |
00000020  e2 8e 8b 20 e2 87 a5 20  e2 8b ae                 |... ... ...|
0000002b
:
:
rm -fr dotdir/ dir/
:
mkdir -p .dotdir/
touch .dotdir/.dotdir-dotchild
touch .dotdir/dotdir-child
mkdir -p dir/
touch dir/.dir-dotchild
touch dir/dir-child
:
rm -fr file
:
shell2py find -maxdepth 1 -type d
import os

def find(top):
    """find --maxdepth 1 --type d"""

    print(top)
    for (dirpath, dirnames, filenames) in os.walk(top):

        depth = 1 + dirpath.count(os.sep)
        if depth > 1:
            continue

        dirnames[:] = sorted(dirnames)
        for dirname in dirnames:
            found_dir = os.path.join(dirpath, dirname)
            print(found_dir)

find(top=".")
bin/find.py -maxdepth 1 -type d |grep i
./.dotdir
./.git
./bin
./dir
:
shell2py find -name '.?*'
import os

def find(top):
    """find --name '.?*'"""

    print(top)
    for (dirpath, dirnames, filenames) in os.walk(top):

        dirnames[:] = list(_ for _ in dirnames if _.startswith("."))
        dirnames[:] = sorted(dirnames)
        for dirname in dirnames:
            found_dir = os.path.join(dirpath, dirname)
            print(found_dir)

        filenames[:] = list(_ for _ in filenames if _.startswith("."))
        filenames[:] = sorted(filenames)
        for filename in filenames:
            found_file = os.path.join(dirpath, filename)
            print(found_file)

find(top=".")
bin/find.py -name '.?*' >file
head -4 file
.
./.dotdir
./.git
./.dotdir/.dotdir-dotchild
:
shell2py find -name '.?*' -prune -o -print
import os

def find(top):
    """find --name '.?*' --prune --o --print"""

    print(top)
    for (dirpath, dirnames, filenames) in os.walk(top):

        dirnames[:] = list(_ for _ in dirnames if not _.startswith("."))
        dirnames[:] = sorted(dirnames)
        for dirname in dirnames:
            found_dir = os.path.join(dirpath, dirname)
            print(found_dir)

        filenames[:] = list(_ for _ in filenames if not _.startswith("."))
        filenames[:] = sorted(filenames)
        for filename in filenames:
            found_file = os.path.join(dirpath, filename)
            print(found_file)

find(top=".")
bin/find.py -name '.?*' -prune -o -print >file
head -10 file
.
./bin
./dir
./Makefile
./README.md
./file
./make.log
./bin/__pycache__
./bin/_scraps_.py
./bin/dig.py
:
shell2py find -type d
import os

def find(top):
    """find --type d"""

    print(top)
    for (dirpath, dirnames, filenames) in os.walk(top):

        dirnames[:] = sorted(dirnames)
        for dirname in dirnames:
            found_dir = os.path.join(dirpath, dirname)
            print(found_dir)

find(top=".")
bin/find.py -type d >file
head -10 file
.
./.dotdir
./.git
./bin
./dir
./.git/hooks
./.git/info
./.git/logs
./.git/objects
./.git/refs
:
shell2py find -name '.?*' -prune -o -type d -print
import os

def find(top):
    """find --name '.?*' --prune --o --type d --print"""

    print(top)
    for (dirpath, dirnames, filenames) in os.walk(top):

        dirnames[:] = list(_ for _ in dirnames if not _.startswith("."))
        dirnames[:] = sorted(dirnames)
        for dirname in dirnames:
            found_dir = os.path.join(dirpath, dirname)
            print(found_dir)

find(top=".")
bin/find.py -name '.?*' -prune -o -type d -print >file
head -10 file
.
./bin
./dir
./bin/__pycache__
:
rm -fr file
:
:
:
rm -fr file
:
shell2py grep.py -anw 'def|jkl|pqr'
import re
import sys

def grep(pyregex):

    fd = sys.stdout.fileno()
    lines = 0
    while True:
        line = sys.stdin.buffer.readline()
        if not line:

            break

        lines += 1
        if re.search(pyregex, string=line):

            data = str(lines).encode() + b":" + line
            os.write(fd, data)

grep(rb"\b(def|jkl|pqr)\b")
:
echo -n 'abc@def ghi@jklmno@pqr stu@vwx' |tr '@' '\n' >file && hexdump -C file
00000000  61 62 63 0a 64 65 66 20  67 68 69 0a 6a 6b 6c 6d  |abc.def ghi.jklm|
00000010  6e 6f 0a 70 71 72 20 73  74 75 0a 76 77 78        |no.pqr stu.vwx|
0000001e
cat file |grep.py -anw 'def|jkl|pqr'
2:def ghi
4:pqr stu
cat file |grep.py -aw 'def|jkl|pqr'
def ghi
pqr stu
cat file |grep.py -a 'def|jkl|pqr'
def ghi
jklmno
pqr stu
(cat file |grep.py 'def|jkl|pqr') || echo "+ exit $?"
grep.py: error: choose argument -a
+ exit 2
:
rm -fr file
:
:
shell2py less -FIXR
import shlex
import subprocess
import sys

shline = "less -FIXR"
run = subprocess.run(shlex.split("less -FIXR"), shell=False)

if run.returncode:
    sys.stderr.write("+ exit {}\n".format(run.returncode))
    sys.exit(run.returncode)
:
ls |less.py -FIXR  # hangs at screens of less than 6 lines
Makefile
README.md
bin
dir
make.log
:
:
shell2py tac -
def tac_file(file):

    with open(file) as reading:
        isatty = reading.isatty()

        if isatty:
            sys.stderr.write("Press âŒƒD EOF to quit\n")

        lines = reading.readlines()

    if isatty:
        sys.stderr.write("\n")

    for line in lines[::-1]:
        sys.stdout.write(line)


files = ["/dev/stdin"]
for file in files:
    tac_file(file)
bash -c 'echo A; echo B; echo C; echo -n Z' |bin/tac.py -
ZC
B
A
:
:
:
rm -fr dir/ dir.tgz
:
mkdir -p dir/a/b/c dir/p/q/r
echo hello >dir/a/b/d
echo goodbye > dir/a/b/e
bin/tar.py czf dir.tgz dir/
:
:
shell2py tar tvf dir.tgz
import datetime as dt
import os
import tarfile


def tar_list(filepath):
    """List tarred files, a la 'tar tvf'"""

    # Visit each Dir or File

    top = os.path.realpath(os.getcwd())
    with tarfile.open(filepath) as untarring:  # instance of 'tarfile.TarFile'
        names = untarring.getnames()

        for name in names:
            member = untarring.getmember(name)

            # Skip the Dir or File if not at or below Top

            outpath = os.path.realpath(name)
            outdir = os.path.dirname(outpath)

            if top != outdir:
                assert outdir.startswith(top + os.sep), (outdir, top)

            # Trace the walk

            print(tar_member_details(member))


def tar_member_details(member):
    """Return such as '-rw-r--r-- jqdoe/staff 8 2021-09-03 20:41 dir/a/b/e'"""

    d_perm = "d" if member.isdir() else "-"
    bits = ((9 * "0") + bin(member.mode)[len("0b") :])[-9:]
    perms = d_perm + "".join("rwxrwxrwx"[_] for _ in range(len(bits)))

    member_uname = "..."  # ellipsis "..." is more anonymous than "member.uname"
    member_gname = "..."  # ellipsis "..." is more anonymous than "member.gname"
    owns = member_uname + os.sep + member_gname

    str_size = "." if member.isdir() else str(member.size)  # 0 at dirs is meaningless

    when = dt.datetime.fromtimestamp(member.mtime)
    stamp = when.strftime("%Y-%m-%d %H:%M")

    name = (member.name + os.sep) if member.isdir() else member.name

    line = "{} {} {} {} {}".format(perms, owns, str_size, stamp, name)

    return line


tar_list("dir.tgz")
bin/tar.py tvf dir.tgz |sed 's,202.-..-.. ..:..,2021-09-11 11:30,'
drwxrwxrwx .../... . 2021-09-11 11:30 dir/
drwxrwxrwx .../... . 2021-09-11 11:30 dir/a/
drwxrwxrwx .../... . 2021-09-11 11:30 dir/p/
drwxrwxrwx .../... . 2021-09-11 11:30 dir/p/q/
drwxrwxrwx .../... . 2021-09-11 11:30 dir/p/q/r/
drwxrwxrwx .../... . 2021-09-11 11:30 dir/a/b/
drwxrwxrwx .../... . 2021-09-11 11:30 dir/a/b/c/
-rwxrwxrwx .../... 6 2021-09-11 11:30 dir/a/b/d
-rwxrwxrwx .../... 8 2021-09-11 11:30 dir/a/b/e
:
shell2py tar xvkf dir.tgz
import os
import sys
import tarfile


def tar_extract(filepath):
    """Extract tarred files, a la 'tar xvkf'"""

    exists = list()

    # Walk to each file or dir found inside

    top = os.path.realpath(os.getcwd())
    with tarfile.open(filepath) as untarring:  # instance of 'tarfile.TarFile'
        names = untarring.getnames()

        for name in names:
            member = untarring.getmember(name)

            # Skip the Dir or File if not at or below Top

            outpath = os.path.realpath(name)
            outdir = os.path.dirname(outpath)

            if top != outdir:
                assert outdir.startswith(top + os.sep), (outdir, top)

            # Trace the walk and make the Dirs

            if member.isdir():
                stderr_print(name + os.sep)

                if not os.path.isdir(outpath):
                    os.makedirs(outpath)

                continue

            stderr_print(name)

            # Visit each Dir or File

            with untarring.extractfile(name) as incoming:

                # Skip File's created before now

                if os.path.exists(name):
                    stderr_print(
                        "tar.py: {}: Cannot open: File exists".format(name)
                    )
                    exists.append(name)

                    continue

                # Fetch the bytes of the Member

                member_bytes = incoming.read()
                member_size = len(member_bytes)
                assert member_size == member.size, (member_size, member.size)

                # Write the bytes as a separate File

                with open(outpath, "wb") as outgoing:
                    outgoing.write(member_bytes)

                # : also extract the Perms and Stamp, but not so much the Owns

    if exists:
        stderr_print("tar: Exiting with failure status due to previous errors")
        sys.exit(2)


# deffed in many files  # missing from docs.python.org
def stderr_print(*args, **kwargs):
    """Like Print, but flush don't write Stdout and do write and flush Stderr"""

    sys.stdout.flush()
    print(*args, **kwargs, file=sys.stderr)
    sys.stderr.flush()

    # else caller has to "{}\n".format(...) and flush


tar_extract("dir.tgz")
rm -fr dir/
bin/tar.py xvkf dir.tgz
dir/
dir/a/
dir/p/
dir/p/q/
dir/p/q/r/
dir/a/b/
dir/a/b/c/
dir/a/b/d
dir/a/b/e
bin/tar.py xvkf dir.tgz || echo "+ exit $?"
dir/
dir/a/
dir/p/
dir/p/q/
dir/p/q/r/
dir/a/b/
dir/a/b/c/
dir/a/b/d
tar.py: dir/a/b/d: Cannot open: File exists
dir/a/b/e
tar.py: dir/a/b/e: Cannot open: File exists
tar: Exiting with failure status due to previous errors
+ exit 2
:
shell2py tar xvf dir.tgz
import os
import sys
import tarfile


def tar_extract(filepath):
    """Extract tarred files, a la 'tar xvf'"""

    # Walk to each file or dir found inside

    top = os.path.realpath(os.getcwd())
    with tarfile.open(filepath) as untarring:  # instance of 'tarfile.TarFile'
        names = untarring.getnames()

        for name in names:
            member = untarring.getmember(name)

            # Skip the Dir or File if not at or below Top

            outpath = os.path.realpath(name)
            outdir = os.path.dirname(outpath)

            if top != outdir:
                assert outdir.startswith(top + os.sep), (outdir, top)

            # Trace the walk and make the Dirs

            if member.isdir():
                stderr_print(name + os.sep)

                if not os.path.isdir(outpath):
                    os.makedirs(outpath)

                continue

            stderr_print(name)

            # Visit each Dir or File

            with untarring.extractfile(name) as incoming:

                # Fetch the bytes of the Member

                member_bytes = incoming.read()
                member_size = len(member_bytes)
                assert member_size == member.size, (member_size, member.size)

                # Write the bytes as a separate File

                with open(outpath, "wb") as outgoing:
                    outgoing.write(member_bytes)

                # : also extract the Perms and Stamp, but not so much the Owns


# deffed in many files  # missing from docs.python.org
def stderr_print(*args, **kwargs):
    """Like Print, but flush don't write Stdout and do write and flush Stderr"""

    sys.stdout.flush()
    print(*args, **kwargs, file=sys.stderr)
    sys.stderr.flush()

    # else caller has to "{}\n".format(...) and flush


tar_extract("dir.tgz")
bin/tar.py xvf dir.tgz
dir/
dir/a/
dir/p/
dir/p/q/
dir/p/q/r/
dir/a/b/
dir/a/b/c/
dir/a/b/d
dir/a/b/e
:
:
shell2py tar tf dir.tgz
import os
import tarfile


def tar_list(filepath):
    """List tarred files, a la 'tar tf'"""

    # Visit each Dir or File

    top = os.path.realpath(os.getcwd())
    with tarfile.open(filepath) as untarring:  # instance of 'tarfile.TarFile'
        names = untarring.getnames()

        for name in names:
            member = untarring.getmember(name)

            # Skip the Dir or File if not at or below Top

            outpath = os.path.realpath(name)
            outdir = os.path.dirname(outpath)

            if top != outdir:
                assert outdir.startswith(top + os.sep), (outdir, top)

            if member.isdir():
                print(name + os.sep)
            else:
                print(name)


tar_list("dir.tgz")
bin/tar.py tf dir.tgz
dir/
dir/a/
dir/p/
dir/p/q/
dir/p/q/r/
dir/a/b/
dir/a/b/c/
dir/a/b/d
dir/a/b/e
:
shell2py tar xkf dir.tgz
import os
import sys
import tarfile


def tar_extract(filepath):
    """Extract tarred files, a la 'tar xkf'"""

    exists = list()

    # Walk to each file or dir found inside

    top = os.path.realpath(os.getcwd())
    with tarfile.open(filepath) as untarring:  # instance of 'tarfile.TarFile'
        names = untarring.getnames()

        for name in names:
            member = untarring.getmember(name)

            # Skip the Dir or File if not at or below Top

            outpath = os.path.realpath(name)
            outdir = os.path.dirname(outpath)

            if top != outdir:
                assert outdir.startswith(top + os.sep), (outdir, top)

            # Make the Dirs

            if member.isdir():

                if not os.path.isdir(outpath):
                    os.makedirs(outpath)

                continue

            # Visit each Dir or File

            with untarring.extractfile(name) as incoming:

                # Skip File's created before now

                if os.path.exists(name):
                    stderr_print(
                        "tar.py: {}: Cannot open: File exists".format(name)
                    )
                    exists.append(name)

                    continue

                # Fetch the bytes of the Member

                member_bytes = incoming.read()
                member_size = len(member_bytes)
                assert member_size == member.size, (member_size, member.size)

                # Write the bytes as a separate File

                with open(outpath, "wb") as outgoing:
                    outgoing.write(member_bytes)

                # : also extract the Perms and Stamp, but not so much the Owns

    if exists:
        stderr_print("tar: Exiting with failure status due to previous errors")
        sys.exit(2)


# deffed in many files  # missing from docs.python.org
def stderr_print(*args, **kwargs):
    """Like Print, but flush don't write Stdout and do write and flush Stderr"""

    sys.stdout.flush()
    print(*args, **kwargs, file=sys.stderr)
    sys.stderr.flush()

    # else caller has to "{}\n".format(...) and flush


tar_extract("dir.tgz")
rm -fr dir/
bin/tar.py xkf dir.tgz
bin/tar.py xkf dir.tgz || echo "+ exit $?"
tar.py: dir/a/b/d: Cannot open: File exists
tar.py: dir/a/b/e: Cannot open: File exists
tar: Exiting with failure status due to previous errors
+ exit 2
:
shell2py tar xf dir.tgz
import os
import tarfile


def tar_extract(filepath):
    """Extract tarred files, a la 'tar xf'"""

    # Walk to each file or dir found inside

    top = os.path.realpath(os.getcwd())
    with tarfile.open(filepath) as untarring:  # instance of 'tarfile.TarFile'
        names = untarring.getnames()

        for name in names:
            member = untarring.getmember(name)

            # Skip the Dir or File if not at or below Top

            outpath = os.path.realpath(name)
            outdir = os.path.dirname(outpath)

            if top != outdir:
                assert outdir.startswith(top + os.sep), (outdir, top)

            # Make the Dirs

            if member.isdir():

                if not os.path.isdir(outpath):
                    os.makedirs(outpath)

                continue

            # Visit each Dir or File

            with untarring.extractfile(name) as incoming:

                # Fetch the bytes of the Member

                member_bytes = incoming.read()
                member_size = len(member_bytes)
                assert member_size == member.size, (member_size, member.size)

                # Write the bytes as a separate File

                with open(outpath, "wb") as outgoing:
                    outgoing.write(member_bytes)

                # : also extract the Perms and Stamp, but not so much the Owns


tar_extract("dir.tgz")
bin/tar.py xf dir.tgz
:
:
rm -fr p.py
:
shell2py tar tf dir.tgz dir/a
import fnmatch
import os
import sys
import tarfile


def tar_list(filepath, patterns):
    """List tarred files, a la 'tar -tf dir/a'"""

    fnmatches = tar_fnmatches_enter(patterns)

    # Visit each Dir or File

    top = os.path.realpath(os.getcwd())
    with tarfile.open(filepath) as untarring:  # instance of 'tarfile.TarFile'
        names = untarring.getnames()

        for name in names:
            member = untarring.getmember(name)

            # Skip the Dir or File if not at or below Pattern

            if not tar_fnmatches_find_name(fnmatches, name=name):
                continue

            # Skip the Dir or File if not at or below Top

            outpath = os.path.realpath(name)
            outdir = os.path.dirname(outpath)

            if top != outdir:
                assert outdir.startswith(top + os.sep), (outdir, top)

            if member.isdir():
                print(name + os.sep)
            else:
                print(name)

    if tar_fnmatches_exit(fnmatches):
        sys.exit(1)


def tar_fnmatches_enter(patterns):
    """Starting counting fnmatch'es"""

    fnmatches = dict()
    for pat in patterns:
        fnmatches[pat] = 0

    return fnmatches


def tar_fnmatches_find_name(fnmatches, name):
    """Count fnmatch'es found, if any"""

    count = 0
    for pat in fnmatches.keys():

        at_or_below_pat = False
        name_or_above = name
        while name_or_above:
            if fnmatch.fnmatchcase(name_or_above, pat=pat):
                at_or_below_pat = True
                break
            name_or_above = os.path.dirname(name_or_above)

        if at_or_below_pat:
            fnmatches[pat] += 1

            count += 1

    return count


def tar_fnmatches_exit(fnmatches):
    """Count each Pattern not found, and trace it too"""

    count = 0
    for (pat, hits) in fnmatches.items():
        if not hits:
            stderr_print("tar: {}: Not found in archive".format(pat))
            count += 1

            # Mac and Linux rstrip 1 or all of the trailing '/' slashes in a Pattern

    return count


# deffed in many files  # missing from docs.python.org
def stderr_print(*args, **kwargs):
    """Like Print, but flush don't write Stdout and do write and flush Stderr"""

    sys.stdout.flush()
    print(*args, **kwargs, file=sys.stderr)
    sys.stderr.flush()

    # else caller has to "{}\n".format(...) and flush


tar_list("dir.tgz", patterns=["dir/a"])
bin/tar.py tf dir.tgz dir/a
dir/a/
dir/a/b/
dir/a/b/c/
dir/a/b/d
dir/a/b/e
:
shell2py tar tf dir.tgz dir dir/a// dir >p.py
tail -2 p.py

tar_list("dir.tgz", patterns=["dir", "dir/a", "dir"])
bin/tar.py tf dir.tgz dir dir/a/b/d/// dir
dir/
dir/a/
dir/p/
dir/p/q/
dir/p/q/r/
dir/a/b/
dir/a/b/c/
dir/a/b/d
dir/a/b/e
:
shell2py tar xf dir.tgz -O 'dir/a/*/?' >p.py
tail -2 p.py

tar_extract("dir.tgz", patterns=["dir/a/*/?"])
bin/tar.py xf dir.tgz -O 'dir/a/*/?'
hello
goodbye
:
:
rm -fr dir/ dir.tgz p.py
:
:
:
:
git ls-files
Makefile
README.md
bin/_scraps_.py
bin/dig.py
bin/echo.py
bin/find.py
bin/grep.py
bin/less.py
bin/ls.py
bin/scp.py
bin/shell2py
bin/shell2py.py
bin/ssh.py
bin/tac.py
bin/tar.py
make.log
git status --short --ignored |grep -v '^ M ' |(grep '[.]py$' || :)
:
:
: copied by: git clone https://github.com/pelavarre/shell2py.git
rm -fr .dotfile .dotdir/ dir/ dir.tgz file p.py
rm -fr bin/__pycache__/
